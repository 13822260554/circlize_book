[
["other-utilities.html", "Chapter 5 Other utilities 5.1 circlize() and reverse.circlize() 5.2 convert_length(), convert_x() and convert_y() 5.3 circos.info() and circos.clear() 5.4 Highlight sectors and tracks", " Chapter 5 Other utilities 5.1 circlize() and reverse.circlize() circlize transform data points in several coordinate systems and it is basically done by the core function circlize(). The function transforms from data coordinate (coordinate in the cells) to the polar coordinate and its companion reverse.circlize() transforms from polar coordinate to data coordinate. The default transformation is applied in the current cell. factors = c(&quot;a&quot;, &quot;b&quot;) circos.initialize(factors, xlim = c(0, 1)) circos.track(ylim = c(0, 1)) # x = 0.5, y = 0.5 in sector a and track 1 circlize(0.5, 0.5, sector.index = &quot;a&quot;, track.index = 1) ## theta rou ## [1,] 270.5 0.7818898 # theta = 90, rou = 0.9 in the polar coordinate reverse.circlize(90, 0.9, sector.index = &quot;a&quot;, track.index = 1) ## x y ## [1,] 1.50838 1.090551 ## x y ## [1,] 0.5027933 1.090551 You can see the results are different for two reverse.circlize() calls although it is the same points in the polar coordinate, because they are mapped to different cells. circlize() and reverse.circlize() can be used to connect two circular plots if they are drawn on a same page. This provides a way to build more complex plots. Basically, the two circular plots will have a same polar coordiante, then, the manipulation of circlize-&gt;reverse.circlize-&gt;circlize can transform coordinate for data points from the first circular plot to the second. 5.2 convert_length(), convert_x() and convert_y() For the functions in circlize package, they needs arguments which are lengths measured either in the canvas coordinate or in the data coordinate. E.g. track.height argument in circos.track() corresponds to percent of radius in the unit circle. circlize package is built in the R base graphic system which is not straightforward to define a length with absolute units (e.g. a line of length 2 cm). circlize provides three functions which convert absolute units to the canvas coordinate or the data coordinate accordingly. convert_length() converts absolute units to the canvas coordinate. Since the aspect ratio for canvas coordinate is always set to 1, it doesn’t matter whether to convert units in the x direction or in the y direction. The usage of convert_length() is straightforward, supported units are mm, cm and inches. convert_length(2, &quot;mm&quot;) Since convert_length() is mostly used to define heights on the radical direction, e.g. track height or height of track margins, the function has another name convert_height(), or the short name uh(). convert_x() and convert_y(), or the short version ux() and uy(), convert absolute units to the data coordinate. By default, the conversion is applied in the “current” cell, but it can still be specified by sector.index and track.index. Since the width of the cell is not the same from the top to the bottom in the cell, for convert_x() or ux() function, the position on y direction where the convert is applied needs to be specified. By default it is at the middle point on y-axis. fa = letters[1:10] circos.par(cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0)) circos.initialize(fa, xlim = cbind(rep(0, 10), runif(10, 0.5, 1.5))) circos.track(ylim = c(0, 1), track.height = uh(5, &quot;mm&quot;), panel.fun = function(x, y) { circos.lines(c(0, 0 + ux(5, &quot;mm&quot;)), c(0.5, 0.5), col = &quot;blue&quot;) }) circos.par(track.margin = c(0, uh(2, &quot;mm&quot;))) circos.track(ylim = c(0, 1), track.height = uh(1, &quot;cm&quot;), panel.fun = function(x, y) { xcenter = get.cell.meta.data(&quot;xcenter&quot;) circos.lines(c(xcenter, xcenter), c(0, uy(1, &quot;cm&quot;)), col = &quot;red&quot;) }) circos.par(track.margin = c(0, uh(5, &quot;mm&quot;))) circos.track(ylim = c(0, 1), track.height = uh(1, &quot;inches&quot;), panel.fun = function(x, y) { line_length_on_x = ux(1*sqrt(2)/2, &quot;cm&quot;) line_length_on_y = uy(1*sqrt(2)/2, &quot;cm&quot;) circos.lines(c(0, line_length_on_x), c(0, line_length_on_y), col = &quot;orange&quot;) }) circos.clear() 5.3 circos.info() and circos.clear() You can get basic information of your current circular plot by circos.info(). The function can be called at any time. factors = letters[1:3] circos.initialize(factors = factors, xlim = c(1, 2)) circos.info() ## All your sectors: ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## No track has been created circos.track(ylim = c(0, 1)) circos.info(sector.index = &quot;a&quot;, track.index = 1) ## sector index: &#39;a&#39; ## track index: 1 ## xlim: [1, 2] ## ylim: [0, 1] ## cell.xlim: [0.991453, 2.008547] ## cell.ylim: [-0.1, 1.1] ## xplot (degree): [360, 241] ## yplot (radius): [0.79, 0.99] ## track.margin: c(0.01, 0.01) ## cell.padding: c(0.02, 1, 0.02, 1) ## ## Your current sector.index is c ## Your current track.index is 1 circos.clear() It can also add labels to cells by circos.info(plot = TRUE). You should always call circos.clear() at the end of every circular plot. There are several parameters for circular plot which can only be set before circos.initialize(), thus, before you draw the next circular plot, you need to reset all these parameters. 5.4 Highlight sectors and tracks draw.sector() draws sectors, rings or their parts. This function is useful if you want to highlight some parts of your circular plot. This function needs arguments of the position of circle center, the start degree and the end degree for sectors, and radius for two edges (or one edge) which are up or bottom borders. draw.sector() is independent from the circular plot. Possible usage of draw.sector() is as follows. draw.sector(start.degree, end.degree, rou1) draw.sector(start.degree, end.degree, rou1, rou2, center) draw.sector(start.degree, end.degree, rou1, rou2, center, col, border, lwd, lty) Directions from start.degree and end.degree is important for drawing sectors. By default, it is clock wise. draw.sector(start.degree, end.degree, clock.wise = FALSE) Following code shows examples of draw.sector(). par(mar = c(1, 1, 1, 1)) plot(c(-1, 1), c(-1, 1), type = &quot;n&quot;, axes = FALSE, ann = FALSE, asp = 1) draw.sector(20, 0) draw.sector(30, 60, rou1 = 0.8, rou2 = 0.5, clock.wise = FALSE, col = &quot;#FF000080&quot;) draw.sector(350, 1000, col = &quot;#00FF0080&quot;, border = NA) draw.sector(0, 180, rou1 = 0.25, center = c(-0.5, 0.5), border = 2, lwd = 2, lty = 2) draw.sector(0, 360, rou1 = 0.7, rou2 = 0.6, col = &quot;#0000FF80&quot;) In order to highlight cells in the circular plot, we can use get.cell.meta.data() to get the information of positions of cells. E.g. the start degree and end degree can be obtained through cell.start.degree and cell.end.degree, and the position of the top border and bottom border can be obtained through cell.top.radius and cell.bottom.radius. Following code shows several examples to highlight sectors and tracks. factors = letters[1:8] circos.initialize(factors, xlim = c(0, 1)) for(i in 1:3) { circos.track(ylim = c(0, 1)) } circos.info(plot = TRUE) If we want to highlight sector a: draw.sector(get.cell.meta.data(&quot;cell.start.degree&quot;, sector.index = &quot;a&quot;), get.cell.meta.data(&quot;cell.end.degree&quot;, sector.index = &quot;a&quot;), rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 1), col = &quot;#FF000040&quot;) If we want to highlight track 1: draw.sector(0, 360, rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 1), rou2 = get.cell.meta.data(&quot;cell.bottom.radius&quot;, track.index = 1), col = &quot;#00FF0040&quot;) If we want to highlight track 2 and 3 in sector e and f: draw.sector(get.cell.meta.data(&quot;cell.start.degree&quot;, sector.index = &quot;e&quot;), get.cell.meta.data(&quot;cell.end.degree&quot;, sector.index = &quot;f&quot;), rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, track.index = 2), rou2 = get.cell.meta.data(&quot;cell.bottom.radius&quot;, track.index = 3), col = &quot;#0000FF40&quot;) If we want to highlight specific regions such as a small region inside cell h:2, we can use circlize() to calculate the positions in the polar coordinate. But always keep in mind that x-axis in the cell are always clock wise. pos = circlize(c(0.2, 0.8), c(0.2, 0.8), sector.index = &quot;h&quot;, track.index = 2) draw.sector(pos[1, &quot;theta&quot;], pos[2, &quot;theta&quot;], pos[1, &quot;rou&quot;], pos[2, &quot;rou&quot;], clock.wise = TRUE, col = &quot;#00FFFF40&quot;) circos.clear() (#fig:circlize_highlight)Highlight sectors and tracks. If the purpose is to simply highlight complete cells, there is a helper function highlight.sector() for which you only need to specify index for sectors and tracks that you want to to highlight. Paddings of the highligted regions can be set by padding argument which should contain four values representing ratios of the width or height of the highlighted region. One advantage of highlight.sector() is that it supports to add text for the highlighted regions. By default, the text is drawn at that center of the highlighted region. The position on the radical direction can be set by text.vjust argument. factors = letters[1:8] circos.initialize(factors, xlim = c(0, 1)) for(i in 1:4) { circos.track(ylim = c(0, 1)) } circos.info(plot = TRUE) highlight.sector(c(&quot;a&quot;, &quot;h&quot;), track.index = 1, text = &quot;a and h belong to a same group&quot;, facing = &quot;bending.inside&quot;, niceFacing = TRUE, text.vjust = -2, cex = 0.8) highlight.sector(&quot;c&quot;, col = &quot;#00FF0040&quot;) highlight.sector(&quot;d&quot;, col = NA, border = &quot;red&quot;, lwd = 2) highlight.sector(&quot;e&quot;, col = &quot;#0000FF40&quot;, track.index = c(2, 3)) highlight.sector(c(&quot;f&quot;, &quot;g&quot;), col = NA, border = &quot;green&quot;, lwd = 2, track.index = c(2, 3), padding = c(0.1, 0.1, 0.1, 0.1)) highlight.sector(factors, col = &quot;#FFFF0040&quot;, track.index = 4) circos.clear() "]
]
