[
["advanced-layout.html", "Chapter 5 Advanced layout 5.1 Zooming of sectors 5.2 Visualize part of the circle 5.3 Combine multiple circular plots 5.4 Arrange multiple plots", " Chapter 5 Advanced layout 5.1 Zooming of sectors In this section, we will introduce how to zoom sectors and put the zoomed sectors at the same track as the original sectors. Under the default settings, width of sectors are calculated according to the data range in corresponding categories. Normally it is not a good idea to manually modify the default sector width since it reflects useful information of your data. However, sometimes manually modifying the width of sectors can make more advanced plots, e.g. zoomings. The basic idea for zooming is to put original sectors on part of the circle and put the zoomed sectors on the other part, so that in the original sectors, widths are still proportional to their data ranges, and in the zoomed sectors, the widths are also proportional to the data ranges in the zoomed sectors. This type of zooming is rather simple to implement. All we need to do is to copy the data which corresponds to the zoomed sectors, assign new category names to them and append to the original data. The good thing is since the data in the zoomed sectors is exactly the same as the original sectors, if you treat them as normal categories, the graphics will be exactly the same as in the original sectors, but with x direction zoomed. Following example shows more clearly the basic idea of this “horizontal” zooming. We first generate a data frame with six categories. set.seed(123) df = data.frame( factors = sample(letters[1:6], 400, replace = TRUE), x = rnorm(400), y = rnorm(400), stringsAsFactors = FALSE ) We want to zoom sector a and the first 10 points in sector b. First we extract these data and format as a new data frame. zoom_df_a = df[df$factors == &quot;a&quot;, ] zoom_df_b = df[df$factors == &quot;b&quot;, ] zoom_df_b = zoom_df_b[order(zoom_df_b[, 2])[1:10], ] zoom_df = rbind(zoom_df_a, zoom_df_b) Note, we must change the sector name in the zoomed data frame. We just simply add “zoom_” prefix to the original name to show it is a “zoomed” sector. After that, it is attached to the original data frame. zoom_df$factors = paste0(&quot;zoom_&quot;, zoom_df$factors) df2 = rbind(df, zoom_df) In this example, we will put the original cells in the left half of the circle and the zoomed sectors in the right. Here is where the magic thing happens. We simply normalize the width of normal sectors and normalize the width of zoomed sectors separately. Now the sum of the sector width for the original sectors is 1 and the sum of sector width for the zoomed sectors is 1, which means these two types of sectors now have their own half circle. You may notice the sum of the sector.width is not idential to 1. This is fine, they will be further normalized to 1 internally. Strictly speaking, since the gaps between sectors are not taken into consideration, the width of the original sectors are not exactly 180 degree, but the real value is quite close to it. xrange = tapply(df2$x, df2$factors, function(x) max(x) - min(x)) normal_sector_index = unique(df$factors) zoomed_sector_index = unique(zoom_df$factors) sector.width = c(xrange[normal_sector_index] / sum(xrange[normal_sector_index]), xrange[zoomed_sector_index] / sum(xrange[zoomed_sector_index])) sector.width ## b e c f a d zoom_a ## 0.1685162 0.1765301 0.1732999 0.1705148 0.1518915 0.1592475 0.8097123 ## zoom_b ## 0.1902877 Now just make the circular plot in the normal way. All the graphics in sector a and b will be automatically zoomed to sector “zoomed_a” and “zoomed_b”. In following code, since the sector names are added outside the first track, points.overflow.warning is set to FALSE to turn off the warning messages. circos.par(start.degree = 90, points.overflow.warning = FALSE) circos.initialize(df2$factors, x = df2$x, sector.width = sector.width) circos.track(df2$factors, x = df2$x, y = df2$y, panel.fun = function(x, y) { circos.points(x, y, col = &quot;red&quot;, pch = 16, cex = 0.5) circos.text(CELL_META$xcenter, CELL_META$cell.ylim[2] + uy(2, &quot;mm&quot;), CELL_META$sector.index, niceFacing = TRUE) }) Adding links from original sectors to zoomed sectors is a good idea to show where the zooming happens (Figure 5.1). Notice that we manually adjust the position of one end of the sector b link. circos.link(&quot;a&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;a&quot;), &quot;zoom_a&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;zoom_a&quot;), border = NA, col = &quot;#00000020&quot;) circos.link(&quot;b&quot;, c(zoom_df_b[1, 2], zoom_df_b[10, 2]), &quot;zoom_b&quot;, get.cell.meta.data(&quot;cell.xlim&quot;, sector.index = &quot;zoom_b&quot;), rou1 = get.cell.meta.data(&quot;cell.top.radius&quot;, sector.index = &quot;b&quot;), border = NA, col = &quot;#00000020&quot;) circos.clear() Figure 5.1: Zoom sectors. 5.2 Visualize part of the circle canvas.xlim and canvas.ylim parameters in circos.par() are useful to generate plots only in part of the circle. As mentioned in previews chapters, the circular plot is always drawn in a canvas where x values range from -1 to 1 and y values range from -1 to 1. Thus, if canvas.xlim and canvas.ylim are all set to c(0, 1), which means, the canvas is restricted to the right top part, then only sectors between 0 to 90 degree are visible (Figure 5.2). Figure 5.2: One quarter of the circle. To make the right plot in Figure 5.2, we only need to set one sector in the layout and set gap.after to 270. (One sector with gap.after of 270 degree means the width of this sector is exactly 90 degree.) circos.par(&quot;canvas.xlim&quot; = c(0, 1), &quot;canvas.ylim&quot; = c(0, 1), &quot;start.degree&quot; = 90, &quot;gap.after&quot; = 270) factors = &quot;a&quot; # this is the name of your sector circos.initialize(factors = factors, xlim = ...) ... Similar idea can be applied to the circle where in some tracks, only a subset of cells are needed. Gererally there are two ways. The first way is to create the track and add graphics with subset of data that only corresponds to the cells that are needed. And the second way is to create an empty track first and customize the cells by circos.update(). Following code illustrates the two methods (Figure 5.3). factors = letters[1:4] circos.initialize(factors = factors, xlim = c(0, 1)) # directly specify the subset of data df = data.frame(factors = rep(&quot;a&quot;, 100), x = runif(100), y = runif(100)) circos.track(df$factors, x = df$x, y = df$y, panel.fun = function(x, y) { circos.points(x, y, pch = 16, cex = 0.5) }) # create empty track first then fill graphics in the cell circos.track(ylim = range(df$y), bg.border = NA) circos.update(sector.index = &quot;a&quot;, bg.border = &quot;black&quot;) circos.points(df$x, df$y, pch = 16, cex = 0.5) circos.track(factors = factors, ylim = c(0, 1)) circos.track(factors = factors, ylim = c(0, 1)) Figure 5.3: Show subset of cells in tracks. circos.clear() 5.3 Combine multiple circular plots circlize finally makes the circular plot in the base R graphic system. Seperated circular plots actually can be put in a same page by some tricks from the base graphic system. Here the key is par(new = TRUE) which allows to draw a new figure as a new layer directly on the previous canvas region. By setting different canvas.xlim and canvas.ylim, it allows to make more complex plots which include more than one circular plots. Folowing code shows how the two independent circualr plots are added and nested. Figure 5.4 illustrates the invisible canvas coordinate and how the two circular plots overlap. factors = letters[1:4] circos.initialize(factors = factors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, &quot;outer circos&quot;, niceFacing = TRUE) }) circos.clear() par(new = TRUE) # &lt;- magic circos.par(&quot;canvas.xlim&quot; = c(-2, 2), &quot;canvas.ylim&quot; = c(-2, 2)) factors = letters[1:3] circos.initialize(factors = factors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), panel.fun = function(x, y) { circos.text(0.5, 0.5, &quot;inner circos&quot;, niceFacing = TRUE) }) circos.clear() Figure 5.4: Nested circular plots. The second example (Figure 5.5) makes a plot where two circular plots separate from each other. You can use technique introduced in Section 5.2 to only show part of the circle, select proper canvas.xlim and canvas.ylim, and finally arrange the two plots into one page. The source code for generating Figure 5.5 is at src/intro-20-separated.R. Figure 5.5: Two separated circular plots The third example is to draw cells with different radius (Figure 5.6). In fact, it makes four circular plots where only one sector for each plot is plotted. factors = letters[1:4] lim = c(1, 1.1, 1.2, 1.3) for(i in 1:4) { circos.par(&quot;canvas.xlim&quot; = c(-lim[i], lim[i]), &quot;canvas.ylim&quot; = c(-lim[i], lim[i]), &quot;track.height&quot; = 0.4) circos.initialize(factors = factors, xlim = c(0, 1)) circos.track(ylim = c(0, 1), bg.border = NA) circos.update(sector.index = factors[i], bg.border = &quot;black&quot;) circos.points(runif(10), runif(10), pch = 16) circos.clear() par(new = TRUE) } par(new = FALSE) Figure 5.6: Cells with differnet radius. Note above plot is different from the example in Figure 5.3. In Figure 5.3, cells both visible and invisible all belong to a same track and they are in a same circular plot, thus they should have same radius. But for the example here, cells have different radius and they belong to different circular plot. 5.4 Arrange multiple plots circlize is implemented in the base R graphic system, thus, you can use layout() or par(mforw, mfcol) to arrange multiple circular plots in one page (Figure 5.7). layout(matrix(1:9, 3, 3)) for(i in 1:9) { factors = 1:8 par(mar = c(0.5, 0.5, 0.5, 0.5)) circos.par(cell.padding = c(0, 0, 0, 0)) circos.initialize(factors, xlim = c(0, 1)) circos.trackPlotRegion(ylim = c(0, 1), track.height = 0.05, bg.col = rand_color(8), bg.border = NA) for(i in 1:20) { se = sample(1:8, 2) circos.link(se[1], runif(2), se[2], runif(2), col = rand_color(1, transparency = 0.4), border = NA) } circos.clear() } Figure 5.7: Arrange multiple circular plots. "]
]
