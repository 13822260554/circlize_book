[
["modes-of-input.html", "Chapter 8 modes for circos.genomicTrack() 8.1 Normal mode 8.2 Stack mode 8.3 Applications", " Chapter 8 modes for circos.genomicTrack() The behaviour of circos.genomicTrack() and panel.fun will be different according to different input data (e.g. is it a simple data frame or a list of data frames? If it is a data frame, how many numeric columns it has?) and different settings. 8.1 Normal mode 8.1.1 Input is a data frame If input data is a data frame in BED format, region in panel.fun would be a data frame containing start position and end position in the current chromosome which is extracted from data. value is also a data frame which contains columns in data excluding the first three columns. Index of proper numeric columns will be passed by ... if it is set in circos.genomicTrack(). If users want to use such information, they need to pass ... to low-level genomic function such as circos.genoimcPoints() as well. If there are more than one numeric columns, graphics are added for each column repeatedly (with same genomic positions). data = generateRandomBed(nc = 2) circos.genomicTrack(data, numeric.column = 4, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, ...) circos.genomicPoints(region, value) # 1st column in `value` while 4th column in `data` circos.genomicPoints(region, value, numeric.column = 1) }) 8.1.2 Input is a list of data frames If input data is a list of data frames, panel.fun is applied on each data frame iteratively to the current cell. Under such condition, region and value will contain corresponding data in the current data frame. The index for the current data frame can be get by getI(...). Note getI(...) can only be used inside panel.fun and ... argument is mandatory. When numeric.column is specified in circos.genomicTrack(), the length of numeric.column can only be one or the number of data frames, which means, there is only one numeric column that will be used in each data frame. If it is not specified, the first numeric column in each data frame is used. bed_list = list(generateRandomBed(), generateRandomBed()) circos.genomicTrack(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, col = i, ...) }) # column 4 in the first bed and column 5 in the second bed circos.genomicTrack(bed_list, numeric.column = c(4, 5), panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, col = i, ...) }) 8.2 Stack mode circos.genomicTrack() also supports a stack mode by setting stack = TRUE. Under stack mode, Graphics are vertically or radically arranged line by line for each dataset. ylim is re-defined inside the function and the y-axis is splitted into several bins with equal height and graphics are put onto “horizontal” bins (with position y = 1, 2, ...). 8.2.1 Input is a data frame Under stack mode, when input data is a single data frame containing one or more numeric columns, each numeric column defined in numeric.column will be treated as a single unit (recall that when numeric.column is not specified, all numeric columns are used). ylim is re-defined to c(0.5, n+0.5) in which n is number of numeric columns specified. panel.fun is applied iteratively on each numeric column and add graphics to the horizontal line y = i. In this case, actually value in e.g. circos.genomicPoints() doesn’t used for mapping the y positions, while replaced with y = i internally. In each iteration, in panel.fun, region is still the genomic regions in current chromosome, but value only contains current numeric column plus all non-numeric columns. The value of the index of “current” numeric column can be obtained by getI(...). data = generateRandomBed(nc = 2) circos.genomicTrackPlotRegion(data, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, col = i, ...) }) 8.2.2 Input is a list of data frames When input data is a list of data frames, each data frame will be treated as a single unit. ylim is re-defined to c(0.5, n+0.5) in which n is the number of data frames. panel.fun will be applied iteratively on each data frame. In each iteration, in panel.fun, region is still the genomic regions in current chromosome, and value contains columns in current data frame excluding the first three columns. Graphics by low-level genomic functions will be added on the `horizontal’ lines. bed_list = list(generateRandomBed(), generateRandomBed()) circos.genomicTrackPlotRegion(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, ...) }) Under stack mode, if using a data frame with multiple numeric columns, graphics on all horizontal lines share the same genomic positions while if using a list of data frames, the genomic positions can be different. 8.3 Applications In this section, we will show several real examples of making genomic plots under different modes. Again, if you are not happy with these functionalities, you can simply re-implement your plot with the basic circlize functions. 8.3.1 Points To make plots more clear to look at, we only add graphics in the first quarter of the circle and initialize the plot only with chromosome 1. set.seed(999) circos.par(&quot;track.height&quot; = 0.1, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) circos.initializeWithIdeogram(chromosome.index = &quot;chr1&quot;, plotType = NULL) In the example figure (Figure ??), each track contains points under different modes. In track A, it is the most normal way to add points. Here bed only contains one numeric column and points are added at the middle points of regions. bed = generateRandomBed(nr = 300) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, ...) }) pos = get.cell.meta.data(&quot;yplot&quot;) In track B, if it is specified as stack mode, points are added in a horizontal line (additionally identify by a dashed line) because there is only one numeric column in bed. circos.genomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, ...) i = getI(...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = &quot;#00000040&quot;) }) pos = get.cell.meta.data(&quot;yplot&quot;) text(0, mean(pos), &quot;B&quot;, adj = c(1.1, 0.5)) In track C, the input data is a list of two data frames. bed1 = generateRandomBed(nr = 300) bed2 = generateRandomBed(nr = 300) bed_list = list(bed1, bed2) circos.genomicTrackPlotRegion(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, col = i, ...) }) pos = get.cell.meta.data(&quot;yplot&quot;) text(0, mean(pos), &quot;C&quot;, adj = c(1.1, 0.5)) In track D, the list of data frames is plotted under stack mode. circos.genomicTrack(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = &quot;#00000040&quot;) }) pos = get.cell.meta.data(&quot;yplot&quot;) text(0, mean(pos), &quot;D&quot;, adj = c(1.1, 0.5)) NA In track E, the data frame has four numeric columns. Different colors are assigned to different columns. bed = generateRandomBed(nr = 300, nc = 4) circos.genomicTrack(bed, panel.fun = function(region, value, ...) { circos.genomicPoints(region, value, pch = 16, col = 1:4, ...) }) pos = get.cell.meta.data(&quot;yplot&quot;) In track F, the data frame has four columns but is plotted under stack mode. Note here value in panel.fun is a data frame with only one column (but it will be exexuted 4 times in each cell). bed = generateRandomBed(nr = 300, nc = 4) circos.genomicTrack(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicPoints(region, value, pch = 16, col = i, ...) circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = &quot;#00000040&quot;) }) pos = get.cell.meta.data(&quot;yplot&quot;) text(0, mean(pos), &quot;F&quot;, adj = c(1.1, 0.5)) circos.clear() NA NA ## Warning in warning_wrap(&quot;&#39;start.degree&#39; can only be modified before `circos.initialize`, or maybe you forgot to call `circos.clear` in your last plot.&quot;): &#39;start.degree&#39; can only be modified before `circos.initialize`, or ## maybe you forgot to call `circos.clear` in your last plot. ## Warning in warning_wrap(&quot;&#39;canvas.xlim&#39; can only be modified before `circos.initialize`, or maybe you forgot to call `circos.clear` in your last plot.&quot;): &#39;canvas.xlim&#39; can only be modified before `circos.initialize`, or ## maybe you forgot to call `circos.clear` in your last plot. ## Warning in warning_wrap(&quot;&#39;canvas.ylim&#39; can only be modified before `circos.initialize`, or maybe you forgot to call `circos.clear` in your last plot.&quot;): &#39;canvas.ylim&#39; can only be modified before `circos.initialize`, or ## maybe you forgot to call `circos.clear` in your last plot. ## Warning in warning_wrap(&quot;&#39;gap.degree&#39; can only be modified before `circos.initialize`, or maybe you forgot to call `circos.clear` in your last plot.&quot;): &#39;gap.degree&#39; can only be modified before `circos.initialize`, or ## maybe you forgot to call `circos.clear` in your last plot. Figure 8.1: Add points under different modes. 8.3.2 Lines Similar as previous figure, only the first quarter in the circle is visualized. circos.par(&quot;track.height&quot; = 0.1, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) circos.initializeWithIdeogram(chromosome.index = &quot;chr1&quot;, plotType = NULL) In track A, it is the most simple way to add lines. ### track A bed = generateRandomBed(nr = 500) circos.genomicTrackPlotRegion(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = &quot;l&quot;, ...) }) In track B, add lines for a list of data frames. Different colors refers to different data frames. ### track B bed1 = generateRandomBed(nr = 500) bed2 = generateRandomBed(nr = 500) bed_list = list(bed1, bed2) circos.genomicTrackPlotRegion(bed_list, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) In track C, it is the {stack} mode of adding lines. Here the width of each line corresponds to the width of each genomic interval. ### track C circos.genomicTrackPlotRegion(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) In track D, lines for the four numeric columns are added with different colors. ### track D bed = generateRandomBed(nr = 500, nc = 4) circos.genomicTrackPlotRegion(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, col = 1:4, ...) }) In track E, it is the {stack} mode for a data frame with more than one numeric columns. ### track E bed = generateRandomBed(nr = 500, nc = 4) circos.genomicTrackPlotRegion(bed, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicLines(region, value, col = i, ...) }) In track F, we specify {type} to {segment} and use different colors for segments. Note each segment is located at its corresponding y-value. ### track F bed = generateRandomBed(nr = 200) circos.genomicTrackPlotRegion(bed, panel.fun = function(region, value, ...) { circos.genomicLines(region, value, type = &quot;segment&quot;, lwd = 2, col = rand_color(nrow(region)), ...) }) circos.clear() Figure 8.2: Add lines under different modes. 8.3.3 Rectangles Again, initialize the plot with one quarter of the circle (figure ). Also, we want to map the values to colors by {f}. par(mar = c(1, 1, 1, 1)) circos.par(&quot;track.height&quot; = 0.1, start.degree = 90, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270) circos.initializeWithIdeogram(chromosome.index = &quot;chr1&quot;, plotType = NULL) f = colorRamp2(breaks = c(-1, 0, 1), colors = c(&quot;green&quot;, &quot;black&quot;, &quot;red&quot;)) In track A, {bed} has four numeric columns and {stack} mode is used to arrange the heatmap. ### track A bed = generateRandomBed(nr = 100, nc = 4) circos.genomicTrackPlotRegion(bed, stack = TRUE, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, col = f(value[[1]]), border = NA, ...) }) In track B, add rectangles for a list of data frames. Comparing to track A, here genomic regions for each data frame are different, so the positions of rectangles in the first layer are different from that in the second layer. Under {stack} mode, {ytop} and {ybottom} can be set to adjust the height of rectangles. It would be straightforward because for each layer, the position is {y = i} and the height of each rectangle is 1. ### track B bed1 = generateRandomBed(nr = 100) bed2 = generateRandomBed(nr = 100) bed_list = list(bed1, bed2) circos.genomicTrackPlotRegion(bed_list, stack = TRUE, panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.4, ybottom = i - 0.4, col = f(value[[1]]), ...) }) In track C, the plot are the same as track B, but without {stack} mode. Note here we explicitly specify {ylim}. ### track C circos.genomicTrackPlotRegion(bed_list, ylim = c(0, 3), panel.fun = function(region, value, ...) { i = getI(...) circos.genomicRect(region, value, ytop = i + 0.4, ybottom = i - 0.4, col = f(value[[1]]), ...) }) In track D, bars are added to the base line ({y = 0}). ### track D bed = generateRandomBed(nr = 200) circos.genomicTrackPlotRegion(bed, panel.fun = function(region, value, ...) { circos.genomicRect(region, value, ytop.column = 1, ybottom = 0, col = ifelse(value[[1]] &gt; 0, &quot;red&quot;, &quot;green&quot;), ...) cell.xlim = get.cell.meta.data(&quot;cell.xlim&quot;) circos.lines(cell.xlim, c(0, 0), lty = 2, col = &quot;#00000040&quot;) }) circos.clear() Figure 8.3: Add rectangles under different modes. "]
]
