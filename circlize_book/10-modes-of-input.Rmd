```{r, echo = FALSE}
library(circlize)
```

# modes for `circos.genomicTrack()` {#modes-of-input}

The behaviour of `circos.genomicTrack()` and `panel.fun` will be different
according to different input data (e.g. is it a simple data frame or a list of
data frames? If it is a data frame, how many numeric columns it has?) and
different settings.

## Normal mode

### Input is a data frame

If input `data` is a data frame in _BED_ format, `region` in `panel.fun` would
be a data frame containing start position and end position in the current
chromosome which is extracted from `data`. `value` is also a data frame
which contains columns in `data` excluding the first three columns. Index of
proper numeric columns will be passed by `...` if it is set in
`circos.genomicTrack()`. If users want to use such information, they need to
pass `...` to low-level genomic function such as `circos.genoimcPoints()` as
well.

If there are more than one numeric columns, graphics are added for each column
repeatedly (with same genomic positions).

```{r, eval = FALSE}
data = generateRandomBed(nc = 2)
circos.genomicTrack(data, numeric.column = 4, 
    panel.fun = function(region, value, ...) {
        circos.genomicPoints(region, value, ...)
        circos.genomicPoints(region, value)
        # 1st column in `value` while 4th column in `data`
        circos.genomicPoints(region, value, numeric.column = 1)
})
```

### Input is a list of data frames

If input data is a list of data frames, `panel.fun` is applied on each
data frame iteratively to the current cell. Under such condition, `region` and `value`
will contain corresponding data in the current data frame. The index for the
current data frame can be get by `getI(...)`. Note `getI(...)` can only be used
inside `panel.fun` and `...` argument is mandatory.

When `numeric.column` is specified in `circos.genomicTrack()`, the length of
`numeric.column` can only be one or the number of data frames, which means,
there is only one numeric column that will be used in each data frame. If it
is not specified, the first numeric column in each data frame is used.

```{r, eval = FALSE}
bed_list = list(generateRandomBed(), generateRandomBed())
circos.genomicTrack(bed_list,
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, col = i, ...)
})

# column 4 in the first bed and column 5 in the second bed
circos.genomicTrack(bed_list, numeric.column = c(4, 5),
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, col = i, ...)
})
```

## Stack mode

`circos.genomicTrack()` also supports a `stack` mode by setting `stack =
TRUE`. Under `stack` mode, Graphics are vertically or radically arranged line
by line for each dataset. `ylim` is re-defined inside the function and the
y-axis is splitted into several bins with equal height and graphics are put
onto "horizontal" bins (with position `y = 1, 2, ...`).

### Input is a data frame

Under `stack` mode, when input data is a single data frame containing one or
more numeric columns, each numeric column defined in `numeric.column` will be
treated as a single unit (recall that when `numeric.column` is not specified,
all numeric columns are used). `ylim` is re-defined to `c(0.5, n+0.5)` in
which `n` is number of numeric columns specified. `panel.fun` is applied
iteratively on each numeric column and add graphics to the horizontal line `y = i`. 
In this case, actually `value` in e.g. `circos.genomicPoints()` doesn't
used for mapping the y positions, while replaced with `y = i` internally.

In each iteration, in `panel.fun`, `region` is still the genomic regions in
current chromosome, but `value` only contains current numeric column plus all
non-numeric columns. The value of the index of "current" numeric column can be
obtained by `getI(...)`.

```{r, eval = FALSE}
data = generateRandomBed(nc = 2)
circos.genomicTrackPlotRegion(data, stack = TRUE,
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, col = i, ...)
})
```

### Input is a list of data frames

When input data is a list of data frames, each data frame will be treated as a
single unit. `ylim` is re-defined to `c(0.5, n+0.5)` in which `n` is the
number of data frames. `panel.fun` will be applied iteratively on each data
frame. In each iteration, in `panel.fun`, `region` is still the genomic
regions in current chromosome, and `value` contains columns in current data
frame excluding the first three columns. Graphics by low-level genomic
functions will be added on the `horizontal' lines.

```{r, eval = FALSE}
bed_list = list(generateRandomBed(), generateRandomBed())
circos.genomicTrackPlotRegion(bed_list, stack = TRUE,
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, ...)
})
```

Under `stack` mode, if using a data frame with multiple numeric columns,
graphics on all horizontal lines share the same genomic positions while if
using a list of data frames, the genomic positions can be different.

## Applications

In this section, we will show several real examples of making genomic plots under different modes.
Again, if you are not happy with these functionalities, you can simply re-implement
your plot with the basic circlize functions.

### Points

To make plots more clear to look at, we only add graphics in the first quarter
of the circle and initialize the plot only with chromosome 1.

```{r genomic_application_points_0, eval = FALSE}
set.seed(999)

circos.par("track.height" = 0.1, start.degree = 90,
    canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270)
circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)
```

In the example figure (Figure \@ref(genomic-application-points)), each track
contains points under different modes.

In track A, it is the most normal way to add points. Here `bed` only contains
one numeric column and points are added at the middle points of regions.

```{r genomic_application_points_A, eval = FALSE, echo = 1:5}
bed = generateRandomBed(nr = 300)
circos.genomicTrack(bed, panel.fun = function(region, value, ...) {
    circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "A", adj = c(1.1, 0.5))
```

In track B, if it is specified as `stack` mode, points are added in a
horizontal line (additionally identify by a dashed line) because there
is only one numeric column in `bed`.

```{r genomic_application_points_B, eval = FALSE, echo = 1:8}
circos.genomicTrack(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        circos.genomicPoints(region, value, pch = 16, cex = 0.5,...)
        i = getI(...)
        circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "B", adj = c(1.1, 0.5))
```

In track C, the input data is a list of two data frames. 

```{r genomic_application_points_C, eval = FALSE, echo = 1:10}
bed1 = generateRandomBed(nr = 300)
bed2 = generateRandomBed(nr = 300)
bed_list = list(bed1, bed2)
circos.genomicTrackPlotRegion(bed_list, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "C", adj = c(1.1, 0.5))
```

In track D, the list of data frames is plotted under `stack` mode.

```{r genomic_application_points_D, eval = FALSE, echo = 1:9}
circos.genomicTrack(bed_list, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...)
        circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "D", adj = c(1.1, 0.5))
```

In track E, the data frame has four numeric columns. Different colors are assigned to 
different columns.

```{r genomic_application_points_E, eval = FALSE, echo = 1:6}
bed = generateRandomBed(nr = 300, nc = 4)
circos.genomicTrack(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = 1:4, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "E", adj = c(1.1, 0.5))
```

In track F, the data frame has four columns but is plotted under `stack` mode.
Note here  `value` in `panel.fun` is a data frame with only one column (but it
will be exexuted 4 times in each cell).

```{r genomic_application_points_F, eval = FALSE, echo = c(1:11, 14)}
bed = generateRandomBed(nr = 300, nc = 4)
circos.genomicTrack(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, pch = 16, cex = 0.5, col = i, ...)
        circos.lines(CELL_META$cell.xlim, c(i, i), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "F", adj = c(1.1, 0.5))
circos.clear()
```

```{r genomic-application-points, echo = FALSE, fig.cap = "Add points under different modes."}
chunks <- knitr:::knit_code$get()
eval(parse(text = chunks[["genomic_application_points_0"]]))
eval(parse(text = chunks[["genomic_application_points_A"]]))
eval(parse(text = chunks[["genomic_application_points_B"]]))
eval(parse(text = chunks[["genomic_application_points_C"]]))
eval(parse(text = chunks[["genomic_application_points_D"]]))
eval(parse(text = chunks[["genomic_application_points_E"]]))
eval(parse(text = chunks[["genomic_application_points_F"]]))
```

### Lines

Similar as previous figure, only the first quarter in the circle is visualized.

```{r genomic_application_lines_0, eval = FALSE}
circos.par("track.height" = 0.75, start.degree = 90,
    canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270,
    cell.padding = c(0, 0, 0, 0))
circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)
```

In track A, it is the most simple way to add lines.

```{r genomic_application_lines_A, eval = FALSE, echo = 1:6}
### track A
bed = generateRandomBed(nr = 500)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value)
})
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value, area = TRUE)
})
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value, type = "h")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "A", adj = c(1.1, 0.5))
```

In track B, add lines for a list of data frames. Different colors refers to different
data frames.

```{r genomic_application_lines_B, eval = FALSE, echo = 1:9}
### track B
bed1 = generateRandomBed(nr = 500)
bed2 = generateRandomBed(nr = 500)
bed_list = list(bed1, bed2)
circos.genomicTrackPlotRegion(bed_list, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicLines(region, value, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "B", adj = c(1.1, 0.5))
```

In track C, it is the {\tt stack} mode of adding lines. Here the width of each line corresponds
to the width of each genomic interval.

```{r genomic_application_lines_C, eval = FALSE, echo = 1:6}
### track C
circos.genomicTrackPlotRegion(bed_list, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicLines(region, value, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "C", adj = c(1.1, 0.5))
```

In track D, lines for the four numeric columns are added with different colors.

```{r genomic_application_lines_D, eval = FALSE, echo = 1:6}
### track D
bed = generateRandomBed(nr = 500, nc = 4)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value, col = 1:4, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "D", adj = c(1.1, 0.5))
```

In track E, it is the {\tt stack} mode for a data frame with more than one numeric columns.

```{r genomic_application_lines_E, eval = FALSE, echo = 1:7}
### track E
bed = generateRandomBed(nr = 500, nc = 4)
circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicLines(region, value, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "E", adj = c(1.1, 0.5))
```

In track F, we specify {\tt type} to {\tt segment} and use different colors for segments.
Note each segment is located at its corresponding y-value.

```{r genomic_application_lines_F, eval = FALSE, echo = c(1:7, 10)}
### track F
bed = generateRandomBed(nr = 200)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value, type = "segment", lwd = 2, 
            col = rand_color(1), ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "F", adj = c(1.1, 0.5))
circos.clear()
```

```{r genomic-application-lines, echo = FALSE, fig.cap = "Add lines under different modes."}
chunks <- knitr:::knit_code$get()
eval(parse(text = chunks[["genomic_application_lines_0"]]))
eval(parse(text = chunks[["genomic_application_lines_A"]]))
eval(parse(text = chunks[["genomic_application_lines_B"]]))
eval(parse(text = chunks[["genomic_application_lines_C"]]))
eval(parse(text = chunks[["genomic_application_lines_D"]]))
eval(parse(text = chunks[["genomic_application_lines_E"]]))
eval(parse(text = chunks[["genomic_application_lines_F"]]))
```

### Rectangles

Again, initialize the plot with one quarter of the circle (figure \ref{fig:genomic_application_rect}).
Also, we want to map the values to colors by {\tt f}.

```{r genomic_application_rect_0, eval = FALSE}
par(mar = c(1, 1, 1, 1))
circos.par("track.height" = 0.15, start.degree = 90,
    canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270)
circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)
f = colorRamp2(breaks = c(-1, 0, 1), colors = c("green", "black", "red"))
```

In track A, {\tt bed} has four numeric columns and {\tt stack} mode is used to arrange 
the heatmap.

```{r genomic_application_rect_A, eval = FALSE, echo = 1:6}
### track A
bed = generateRandomBed(nr = 100, nc = 4)
circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        circos.genomicRect(region, value, col = f(value[[1]]), border = NA, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "A", adj = c(1.1, 0.5))
```

In track B, add rectangles for a list of data frames. Comparing to track A, here genomic
regions for each data frame are different, so the positions of rectangles in the first layer
are different from that in the second layer.

Under {\tt stack} mode, {\tt ytop} and {\tt ybottom} can be set to adjust the height of 
rectangles. It would be straightforward because for each layer, the position is {\tt y = i}
and the height of each rectangle is 1.

```{r genomic_application_rect_B, eval = FALSE, echo = 1:10}
### track B
bed1 = generateRandomBed(nr = 100)
bed2 = generateRandomBed(nr = 100)
bed_list = list(bed1, bed2)
circos.genomicTrackPlotRegion(bed_list, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicRect(region, value, ytop = i + 0.4, ybottom = i - 0.4,
            col = f(value[[1]]), ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "B", adj = c(1.1, 0.5))
```

In track C, the plot are the same as track B, but without {\tt stack} mode.
Note here we explicitly specify {\tt ylim}.

```{r genomic_application_rect_C, eval = FALSE, echo = 1:7}
### track C
circos.genomicTrackPlotRegion(bed_list, ylim = c(0, 3), 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicRect(region, value, ytop = i + 0.4, ybottom = i - 0.4, 
            col = f(value[[1]]), ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "C", adj = c(1.1, 0.5))
```

In track D, bars are added to the base line ({\tt y = 0}).

```{r genomic_application_rect_D, eval = FALSE, echo = c(1:10, 13)}
### track D
bed = generateRandomBed(nr = 200)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicRect(region, value, ytop.column = 1, ybottom = 0, 
            col = ifelse(value[[1]] > 0, "red", "green"), ...)
            
        cell.xlim = get.cell.meta.data("cell.xlim")
        circos.lines(cell.xlim, c(0, 0), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "D", adj = c(1.1, 0.5))
circos.clear()
```

```{r genomic-application-rect, echo = FALSE, fig.cap = "Add rectangles under different modes."}
chunks <- knitr:::knit_code$get()
eval(parse(text = chunks[["genomic_application_rect_0"]]))
eval(parse(text = chunks[["genomic_application_rect_A"]]))
eval(parse(text = chunks[["genomic_application_rect_B"]]))
eval(parse(text = chunks[["genomic_application_rect_C"]]))
eval(parse(text = chunks[["genomic_application_rect_D"]]))
```
