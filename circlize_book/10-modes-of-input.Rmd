
\section{More details on {\tt circos.genomicTrackPlotRegion}}

The behaviour of {\tt circos.genomicTrackPlotRegion} and {\tt panel.fun} 
will be different according to different input data (e.g. is it a simple data frame or a list
of data frames? If it is a data frame, how many numeric columns it has?) and different settings.

\subsection{Normal mode}

\subsubsection{Input is a data frame}

If input data is a simple data frame, {\tt region} in {\tt panel.fun} would be a data frame
containing start position and end position in the current chromosome which is extracted
from input data. {\tt value} is also a data frame which contains columns in input data
excluding the first three columns. Index of proper numeric columns will be passed by {\tt ...}
if it is set in {\tt circos.genomicTrackPlotRegion}.
So if users want to use such information, they need to pass {\tt ...} to low-level
genomic function such as {\tt circos.genoimcPoints} as well.

If there are more than one numeric columns, all columns that are specified will be added to
the plot.

<<eval=FALSE>>=
bed = generateRandomBed(nc = 2)
# just note `numeric.column` is measured in `bed`
circos.genomicTrackPlotRegion(bed, numeric.column = 4, 
    panel.fun = function(region, value, ...) {
        circos.genomicPoints(region, value, ...)
        circos.genomicPoints(region, value)
        # here `numeric.column` is measured in `value`
        circos.genomicPoints(region, value, numeric.column = 1)
})
@

\subsubsection{Input is a list of data frames}

If input data is a list of data frames, {\tt panel.fun} is applied on each data frame iteratively.
Under such situation, {\tt region} and {\tt value} will contain corresponding data
in the current data frame. The index for the current data frame can be get by {\tt getI(...)}.
For {\tt numeric.column} argument, if input data is a list of data frame, the length can only be one
or the number of data frames, which means, there is only one numeric column that will be used in each data frame.

<<echo=TRUE, eval=FALSE>>=
bedlist = list(generateRandomBed(), generateRandomBed())
circos.genomicTrackPlotRegion(bedlist,
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, col = i, ...)
})

# column 4 in the first bed and column 5 in the second bed
circos.genomicTrackPlotRegion(bedlist, numeric.column = c(4, 5),
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, col = i, ...)
})
@

\subsection{{\tt stack} mode}

{\tt circos.genomicTrackPlotRegion} also supports a {\tt stack} mode. Under {\tt stack} mode,
{\tt ylim} is re-defined inside the function. The y-axis will be splitted into several layers
with equal height and graphics are put on 'horizontal' layers (y = 1, 2, ...).

\subsubsection{Input is a data frame}

Under {\tt stack} mode, when input data is a single data frame containing one or more numeric columns, 
each numeric column defined in {\tt numeric.column} will be treated as a single unit. 
{\tt ylim} is re-defined to {\tt c(0.5, n+0.5)} in which {\tt n} is number of numeric columns. 
{\tt panel.fun} will be applied iteratively on each numeric column. In each iteration, 
in {\tt panel.fun}, {\tt region} is still the genomic regions in current genomic category, 
but {\tt value} only contains current numeric column plus all non-numeric columns.
All low-level genomic graphic functions will be applied on each `horizontal line' {\tt y = i} 
in which {\tt i} is the index of current numeric column. The value of {\tt i} can 
be obtained by {\tt getI(...)}.

<<eval=FALSE>>=
bed = generateRandomBed(nc = 2)
circos.genomicTrackPlotRegion(bed, stack = TRUE,
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, col = i, ...)
})
@

\subsubsection{Input is a list of data frame}

When input data is a list containing data frames, each data frame will be treated 
as a single unit. The situation is quite similar as described previously.
{\tt ylim} is re-defined to {\tt c(0.5, n+0.5)} in which {\tt n} is number of data frames. 
{\tt panel.fun} will be applied iteratively on each data frame. In each
iteration, in {\tt panel.fun}, {\tt region} is still the genomic regions in current 
chromosome, and {\tt value} contains columns in current data frame excluding the first three columns.
Still, graphics by low-level genomic functions will be added on the `horizontal' lines.

<<echo=TRUE, eval=FALSE>>=
bedlist = list(generateRandomBed(), generateRandomBed())
circos.genomicTrackPlotRegion(bedlist, stack = TRUE,
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicPoints(region, value, ...)
})
@

Under {\tt stack} mode, the differentce between using a data frame with multiple numeric columns
and using a list of data frames is if using a data frame, all layers share the same genomic positions
while if using a list of data frames, the genomic positions for each layer can be different.

\section{Applications}

In this section, we will show several real examples of making genomic plots under different modes.

\subsection{Points}

To make plots more clear to look at, we only add graphics in the 1/4 of the circle and
initialize the plot only with chromosome 1 (figure \ref{fig:genomic_application_points}).

<<genomic_application_points_0, eval = FALSE>>=
par(mar = c(1, 1, 1, 1))
set.seed(999)

circos.par("track.height" = 0.1, start.degree = 90,
    canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270)
circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)
@

In track A, it is the most simple way to add points.

<<genomic_application_points_A, eval = FALSE, echo = 1:5>>=
### track A
bed = generateRandomBed(nr = 300)
circos.genomicTrackPlotRegion(bed, panel.fun = function(region, value, ...) {
    circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "A", adj = c(1.1, 0.5))
@

In track B, under {\tt stack} mode, points are added in one horizontal line (here we
additionally add the dashed line) because there is only one numeric column in {\tt bed}.

<<genomic_application_points_B, eval = FALSE, echo = 1:10>>=
### track B
bed = generateRandomBed(nr = 300)
circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        circos.genomicPoints(region, value, pch = 16, cex = 0.5, ...)
        
        i = getI(...)
        cell.xlim = get.cell.meta.data("cell.xlim")
        circos.lines(cell.xlim, c(i, i), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "B", adj = c(1.1, 0.5))
@

In track C, the input data is a list of two data frames. In the plot, sizes of the points
correspond to the values of regions, and colors correspond to different data frames.

<<genomic_application_points_C, eval = FALSE, echo = 1:10>>=
### track C
bed1 = generateRandomBed(nr = 300)
bed2 = generateRandomBed(nr = 300)
bed_list = list(bed1, bed2)
circos.genomicTrackPlotRegion(bed_list, 
    panel.fun = function(region, value, ...) {
        cex = (value[[1]] - min(value[[1]]))/(max(value[[1]]) - min(value[[1]]))
        i = getI(...)
        circos.genomicPoints(region, value, cex = cex, pch = 16, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "C", adj = c(1.1, 0.5))
@

In track D, plot the data frame list under {\tt stack} mode.

<<genomic_application_points_D, eval = FALSE, echo = 1:9>>=
### track D
circos.genomicTrackPlotRegion(bed_list, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        cex = (value[[1]] - min(value[[1]]))/(max(value[[1]]) - min(value[[1]]))
        i = getI(...)
        circos.genomicPoints(region, value, cex = cex, pch = 16, col = i, ...)
        cell.xlim = get.cell.meta.data("cell.xlim")
        circos.lines(cell.xlim, c(i, i), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "D", adj = c(1.1, 0.5))
@

In track E, the data frame has four numeric columns. Different colors are assigned to 
different columns. Note {\tt value} is a data frame with four columns.

<<genomic_application_points_E, eval = FALSE, echo = 1:6>>=
### track E
bed = generateRandomBed(nr = 300, nc = 4)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicPoints(region, value, cex = 0.5, pch = 16, col = 1:4, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "E", adj = c(1.1, 0.5))
@

In track F, the data frame has four columns but is plotted under {\tt stack} mode.
Note here {\tt value} is a data frame with only one column (but it will be exexuted
4 times in each cell).

<<genomic_application_points_F, eval = FALSE, echo = c(1:11, 14)>>=
### track F
bed = generateRandomBed(nr = 300, nc = 4)
circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        cex = (value[[1]] - min(value[[1]]))/(max(value[[1]]) - min(value[[1]]))
        i = getI(...)
        circos.genomicPoints(region, value, cex = cex, pch = 16, col = i, ...)
        
        cell.xlim = get.cell.meta.data("cell.xlim")
        circos.lines(cell.xlim, c(i, i), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "F", adj = c(1.1, 0.5))
circos.clear()
@

<<genomic_application_points, echo = FALSE, out.width = "0.8\\textwidth", fig.cap = "Add points under different modes.">>=
<<genomic_application_points_0>>
<<genomic_application_points_A>>
<<genomic_application_points_B>>
<<genomic_application_points_C>>
<<genomic_application_points_D>>
<<genomic_application_points_E>>
<<genomic_application_points_F>>
@

\subsection{Lines}

Initialize the plot with one quarter of the circle (figure \ref{fig:genomic_application_lines}).

<<genomic_application_lines_0, eval = FALSE>>=
par(mar = c(1, 1, 1, 1))
circos.par("track.height" = 0.1, start.degree = 90,
    canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270)
circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)
@

In track A, it is the most simple way to add lines.

<<genomic_application_lines_A, eval = FALSE, echo = 1:6>>=
### track A
bed = generateRandomBed(nr = 500)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value, type = "l", ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "A", adj = c(1.1, 0.5))
@

In track B, add lines for a list of data frames. Different colors refers to different
data frames.

<<genomic_application_lines_B, eval = FALSE, echo = 1:9>>=
### track B
bed1 = generateRandomBed(nr = 500)
bed2 = generateRandomBed(nr = 500)
bed_list = list(bed1, bed2)
circos.genomicTrackPlotRegion(bed_list, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicLines(region, value, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "B", adj = c(1.1, 0.5))
@

In track C, it is the {\tt stack} mode of adding lines. Here the width of each line corresponds
to the width of each genomic interval.

<<genomic_application_lines_C, eval = FALSE, echo = 1:6>>=
### track C
circos.genomicTrackPlotRegion(bed_list, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicLines(region, value, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "C", adj = c(1.1, 0.5))
@

In track D, lines for the four numeric columns are added with different colors.

<<genomic_application_lines_D, eval = FALSE, echo = 1:6>>=
### track D
bed = generateRandomBed(nr = 500, nc = 4)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value, col = 1:4, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "D", adj = c(1.1, 0.5))
@

In track E, it is the {\tt stack} mode for a data frame with more than one numeric columns.

<<genomic_application_lines_E, eval = FALSE, echo = 1:7>>=
### track E
bed = generateRandomBed(nr = 500, nc = 4)
circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicLines(region, value, col = i, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "E", adj = c(1.1, 0.5))
@

In track F, we specify {\tt type} to {\tt segment} and use different colors for segments.
Note each segment is located at its corresponding y-value.

<<genomic_application_lines_F, eval = FALSE, echo = c(1:7, 10)>>=
### track F
bed = generateRandomBed(nr = 200)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicLines(region, value, type = "segment", lwd = 2, 
            col = rand_color(nrow(region)), ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "F", adj = c(1.1, 0.5))
circos.clear()
@


<<genomic_application_lines, echo = FALSE, out.width = "0.8\\textwidth", fig.cap = "Add lines under different modes.">>=
<<genomic_application_lines_0>>
<<genomic_application_lines_A>>
<<genomic_application_lines_B>>
<<genomic_application_lines_C>>
<<genomic_application_lines_D>>
<<genomic_application_lines_E>>
<<genomic_application_lines_F>>
@

\subsection{Rectangles}

Again, initialize the plot with one quarter of the circle (figure \ref{fig:genomic_application_rect}).
Also, we want to map the values to colors by {\tt f}.

<<genomic_application_rect_0, eval = FALSE>>=
par(mar = c(1, 1, 1, 1))
circos.par("track.height" = 0.1, start.degree = 90,
    canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 270)
circos.initializeWithIdeogram(chromosome.index = "chr1", plotType = NULL)
f = colorRamp2(breaks = c(-1, 0, 1), colors = c("green", "black", "red"))
@

In track A, {\tt bed} has four numeric columns and {\tt stack} mode is used to arrange 
the heatmap.

<<genomic_application_rect_A, eval = FALSE, echo = 1:6>>=
### track A
bed = generateRandomBed(nr = 100, nc = 4)
circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        circos.genomicRect(region, value, col = f(value[[1]]), border = NA, ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "A", adj = c(1.1, 0.5))
@

In track B, add rectangles for a list of data frames. Comparing to track A, here genomic
regions for each data frame are different, so the positions of rectangles in the first layer
are different from that in the second layer.

Under {\tt stack} mode, {\tt ytop} and {\tt ybottom} can be set to adjust the height of 
rectangles. It would be straightforward because for each layer, the position is {\tt y = i}
and the height of each rectangle is 1.

<<genomic_application_rect_B, eval = FALSE, echo = 1:10>>=
### track B
bed1 = generateRandomBed(nr = 100)
bed2 = generateRandomBed(nr = 100)
bed_list = list(bed1, bed2)
circos.genomicTrackPlotRegion(bed_list, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicRect(region, value, ytop = i + 0.4, ybottom = i - 0.4,
            col = f(value[[1]]), ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "B", adj = c(1.1, 0.5))
@

In track C, the plot are the same as track B, but without {\tt stack} mode.
Note here we explicitly specify {\tt ylim}.

<<genomic_application_rect_C, eval = FALSE, echo = 1:7>>=
### track C
circos.genomicTrackPlotRegion(bed_list, ylim = c(0, 3), 
    panel.fun = function(region, value, ...) {
        i = getI(...)
        circos.genomicRect(region, value, ytop = i + 0.4, ybottom = i - 0.4, 
            col = f(value[[1]]), ...)
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "C", adj = c(1.1, 0.5))
@

In track D, bars are added to the base line ({\tt y = 0}).

<<genomic_application_rect_D, eval = FALSE, echo = c(1:10, 13)>>=
### track D
bed = generateRandomBed(nr = 200)
circos.genomicTrackPlotRegion(bed, 
    panel.fun = function(region, value, ...) {
        circos.genomicRect(region, value, ytop.column = 1, ybottom = 0, 
            col = ifelse(value[[1]] > 0, "red", "green"), ...)
            
        cell.xlim = get.cell.meta.data("cell.xlim")
        circos.lines(cell.xlim, c(0, 0), lty = 2, col = "#00000040")
})
pos = get.cell.meta.data("yplot")
text(0, mean(pos), "D", adj = c(1.1, 0.5))
circos.clear()
@

<<genomic_application_rect, echo = FALSE, out.width = "0.8\\textwidth", fig.cap = "Add rectangles under different modes.">>=
<<genomic_application_rect_0>>
<<genomic_application_rect_A>>
<<genomic_application_rect_B>>
<<genomic_application_rect_C>>
<<genomic_application_rect_D>>
@

\subsection{Mixed use of general circos functions}

{\tt panel.fun} is applied on each cell, which means, besides genomic functions, you can 
also use general circos functions to add more graphics. For example, some horizontal lines 
and texts are added to each cell and axes are put on top of each cell:

<<eval=FALSE>>=
circos.genomicTrackPlotRegion(bed, ylim = c(-1, 1),
    panel.fun = function(region, value, ...) {
        circos.genomicPoints(region, value, ...)

        cell.xlim = get.cell.meta.data("cell.xlim")
        for(h in c(-1, -0.5, 0, 0.5, 1)) {
            circos.lines(cell.xlim, c(0, 0), lty = 2, col = "grey")
        }
        circos.text(x, y, labels)
        circos.axis("top")
})
@

\section{Links}

{\tt circos.genomicLink} expects two data frames and it will add links from genomic
intervals in the first data frame to corresponding genomic intervals in the second
data frame (figure \ref{fig:genomic_links}). You can set graphical parameters as a single
scalar or a vector.

<<genomic_links, echo = 2:11, out.width = "\\textwidth", out.height = "0.5\\textwidth", fig.width = 12, fig.height = 6, fig.cap = "Add links from two sets of genomic regions.">>=
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
bed1 = generateRandomBed(nr = 100)
bed1 = bed1[sample(nrow(bed1), 20), ]
bed2 = generateRandomBed(nr = 100)
bed2 = bed2[sample(nrow(bed2), 20), ]
circos.initializeWithIdeogram(plotType = c("axis", "labels"))
circos.genomicLink(bed1, bed2)
circos.clear()

circos.initializeWithIdeogram(plotType = c("axis", "labels"))
circos.genomicLink(bed1, bed2, col = rand_color(nrow(bed1), transparency = 0.5), 
    border = NA)
circos.clear()
par(mfrow = c(1, 1))
@
