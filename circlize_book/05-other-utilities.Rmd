# Other utilities {#other-utilities}

## `circlize()` and `reverse.circlize()` {#circlize_and_reverse_circlize}

**circlize** transform data points in several coordinate systems and it is
basically done by the core function `circlize()`. The function transforms from data
coordinate (coordinate in the cells) to the polar coordinate and its companion
`reverse.circlize()` transforms from polar coordinate to data coordinate. The
default transformation is applied in the `current` cell.

```{r, echo = 2:8}
pdf(NULL)
factors = c("a", "b")
circos.initialize(factors, xlim = c(0, 1))
circos.track(ylim = c(0, 1))
# x = 0.5, y = 0.5 in sector a and track 1
circlize(0.5, 0.5, sector.index = "a", track.index = 1)
# theta = 90, rou = 0.9 in the polar coordinate
reverse.circlize(90, 0.9, sector.index = "a", track.index = 1)
reverse.circlize(90, 0.9, sector.index = "b", track.index = 1)
circos.clear()
invisible(dev.off())
```

You can see the results are different for two `reverse.circlize()` calls
although it is the same points in the polar coordinate, because they are
mapped to different cells.

`circlize()` and `reverse.circlize()` can be used to connect two circular
plots if they are drawn on a same page. This provides a way to build more
complex plots. Basically, the two circular plots will have a same polar
coordiante, then, the manipulation of `circlize->reverse.circlize->circlize`
can transform coordinate for data points from the first circular plot to the
second.

## `convert_length()`, `convert_x()` and `convert_y()` {#convert-functions}

For the functions in **circlize** package, they needs arguments which are
lengths measured either in the canvas coordinate or in the data coordinate.
E.g. `track.height` argument in `circos.track()` corresponds to percent of
radius in the unit circle. **circlize** package is built in the R base graphic
system which is not straightforward to define a length with absolute units
(e.g. a line of length 2 cm). **circlize** provides three functions which
convert absolute units to the canvas coordinate or the data coordinate
accordingly. `convert_length()` converts absolute units to the canvas
coordinate. Since the aspect ratio for canvas coordinate is always set to 1,
it doesn't matter whether to convert units in the x direction or in the y
direction. The usage of `convert_length()` is straightforward, supported units
are `mm`, `cm` and `inches`.

```{r, eval = FALSE}
convert_length(2, "mm")
```

Since `convert_length()` is mostly used to define heights on the radical
direction, e.g. track height or height of track margins, the function has
another name `convert_height()`, or the short name `uh()`.

`convert_x()` and `convert_y()`, or the short version `ux()` and `uy()`,
convert absolute units to the data coordinate. By default, the conversion is
applied in the "current" cell, but it can still be specified by `sector.index`
and `track.index`. Since the width of the cell is not the same from the top to
the bottom in the cell, for `convert_x()` or `ux()` function, the position on
y direction where the convert is applied needs to be specified. By default it
is at the middle point on y-axis.

```{r unit-convert, fig.width = 6, fig.height = 6}
fa = letters[1:10]
circos.par(cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0))
circos.initialize(fa, xlim = cbind(rep(0, 10), runif(10, 0.5, 1.5)))
circos.track(ylim = c(0, 1), track.height = uh(5, "mm"),
    panel.fun = function(x, y) {
        circos.lines(c(0, 0 + ux(5, "mm")), c(0.5, 0.5), col = "blue")
    })
circos.par(track.margin = c(0, uh(2, "mm")))
circos.track(ylim = c(0, 1), track.height = uh(1, "cm"),
    panel.fun = function(x, y) {
        xcenter = get.cell.meta.data("xcenter")
        circos.lines(c(xcenter, xcenter), c(0, uy(1, "cm")), col = "red")
    })
circos.par(track.margin = c(0, uh(5, "mm")))
circos.track(ylim = c(0, 1), track.height = uh(1, "inches"),
    panel.fun = function(x, y) {
        line_length_on_x = ux(1*sqrt(2)/2, "cm")
        line_length_on_y = uy(1*sqrt(2)/2, "cm")
        circos.lines(c(0, line_length_on_x), c(0, line_length_on_y), col = "orange")
    })
circos.clear()
```

## `circos.info()` and `circos.clear()` {#circos-info-and-circos-clear}

You can get basic information of your current circular plot by
`circos.info()`. The function can be called at any time.

```{r, echo = 2:7}
pdf(NULL)
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(1, 2))
circos.info()
circos.track(ylim = c(0, 1))
circos.info(sector.index = "a", track.index = 1)
circos.clear()
invisible(dev.off())
```

It can also add labels to cells by `circos.info(plot = TRUE)`.

You should always call `circos.clear()` at the end of every circular plot.
There are several parameters for circular plot which can only be set before
`circos.initialize()`, thus, before you draw the next circular plot, you need
to reset all these parameters.

## Highlight sectors and tracks {#highlight-sectors-and-tracks}

`draw.sector()` draws sectors, rings or their parts. This function is useful
if you want to highlight some parts of your circular plot. This function needs
arguments of the position of circle center, the start degree and the end
degree for sectors, and radius for two edges (or one edge) which are up or
bottom borders. `draw.sector()` is independent from the circular plot.

Possible usage of `draw.sector()` is as follows.

```{r eval = FALSE}
draw.sector(start.degree, end.degree, rou1)
draw.sector(start.degree, end.degree, rou1, rou2, center)
draw.sector(start.degree, end.degree, rou1, rou2, center, col, border, lwd, lty)
```

Directions from `start.degree` and `end.degree` is important for drawing sectors. 
By default, it is clock wise.

```{r eval = FALSE}
draw.sector(start.degree, end.degree, clock.wise = FALSE)
```

Following code shows examples of draw.sector().

```{r circlize_draw_sector_general, fig.width = 4, fig.height = 4}
par(mar = c(1, 1, 1, 1))
plot(c(-1, 1), c(-1, 1), type = "n", axes = FALSE, ann = FALSE, asp = 1)
draw.sector(20, 0)
draw.sector(30, 60, rou1 = 0.8, rou2 = 0.5, clock.wise = FALSE, col = "#FF000080")
draw.sector(350, 1000, col = "#00FF0080", border = NA)
draw.sector(0, 180, rou1 = 0.25, center = c(-0.5, 0.5), border = 2, lwd = 2, lty = 2)
draw.sector(0, 360, rou1 = 0.7, rou2 = 0.6, col = "#0000FF80")
```

In order to highlight cells in the circular plot, we can use
`get.cell.meta.data()` to get the information of positions of cells. E.g. the
start degree and end degree can be obtained through `cell.start.degree` and
`cell.end.degree`, and the position of the top border and bottom border can be
obtained through `cell.top.radius` and `cell.bottom.radius`.  Following code
shows several examples to highlight sectors and tracks.

```{r circlize_highlight_1, eval = FALSE}
factors = letters[1:8]
circos.initialize(factors, xlim = c(0, 1))
for(i in 1:3) {
    circos.track(ylim = c(0, 1))
}
circos.info(plot = TRUE)
```

If we want to highlight sector a:

```{r circlize_highlight_2, eval = FALSE}
draw.sector(get.cell.meta.data("cell.start.degree", sector.index = "a"),
            get.cell.meta.data("cell.end.degree", sector.index = "a"),
            rou1 = get.cell.meta.data("cell.top.radius", track.index = 1), 
            col = "#FF000040")
```

If we want to highlight track 1:

```{r circlize_highlight_3, eval = FALSE}
draw.sector(0, 360, 
    rou1 = get.cell.meta.data("cell.top.radius", track.index = 1),
    rou2 = get.cell.meta.data("cell.bottom.radius", track.index = 1),
    col = "#00FF0040")           
```

If we want to highlight track 2 and 3 in sector e and f:

```{r circlize_highlight_4, eval = FALSE}
draw.sector(get.cell.meta.data("cell.start.degree", sector.index = "e"),
            get.cell.meta.data("cell.end.degree", sector.index = "f"),
            rou1 = get.cell.meta.data("cell.top.radius", track.index = 2),
            rou2 = get.cell.meta.data("cell.bottom.radius", track.index = 3),
            col = "#0000FF40")
```

If we want to highlight specific regions such as a small region inside cell
`h:2`, we can use `circlize()` to calculate the positions in the polar
coordinate. But always keep in mind that x-axis in the cell are always clock
wise.

```{r circlize_highlight_5, eval = FALSE}
pos = circlize(c(0.2, 0.8), c(0.2, 0.8), sector.index = "h", track.index = 2)
draw.sector(pos[1, "theta"], pos[2, "theta"], pos[1, "rou"], pos[2, "rou"], 
    clock.wise = TRUE, col = "#00FFFF40")
circos.clear()
```

```{r circlize_highlight, echo = FALSE, fig.width = 4, fig.height = 4, fig.cap = "Highlight sectors and tracks."}
chunks <- knitr:::knit_code$get()
eval(parse(text = chunks[["circlize_highlight_1"]]))
eval(parse(text = chunks[["circlize_highlight_2"]]))
eval(parse(text = chunks[["circlize_highlight_3"]]))
eval(parse(text = chunks[["circlize_highlight_4"]]))
eval(parse(text = chunks[["circlize_highlight_5"]]))
```

If the purpose is to simply highlight complete cells, there is a helper
function `highlight.sector()` for which you only need to specify index for
sectors and tracks that you want to to highlight. Paddings of the highligted
regions can be set by `padding` argument which should contain four values
representing ratios of the width or height of the highlighted region.

One advantage of `highlight.sector()` is that it supports to add text for the
highlighted regions. By default, the text is drawn at that center of the
highlighted region. The position on the radical direction can be set by
`text.vjust` argument.

```{r circlize_highlight_sector, fig.width = 4, fig.height = 4}
factors = letters[1:8]
circos.initialize(factors, xlim = c(0, 1))
for(i in 1:4) {
    circos.track(ylim = c(0, 1))
}
circos.info(plot = TRUE)

highlight.sector(c("a", "h"), track.index = 1, text = "a and h belong to a same group",
    facing = "bending.inside", niceFacing = TRUE, text.vjust = -2, cex = 0.8)
highlight.sector("c", col = "#00FF0040")
highlight.sector("d", col = NA, border = "red", lwd = 2)
highlight.sector("e", col = "#0000FF40", track.index = c(2, 3))
highlight.sector(c("f", "g"), col = NA, border = "green", 
    lwd = 2, track.index = c(2, 3), padding = c(0.1, 0.1, 0.1, 0.1))
highlight.sector(factors, col = "#FFFF0040", track.index = 4)
circos.clear()
```

