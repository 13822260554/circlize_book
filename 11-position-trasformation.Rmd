
# Position transformation

There is one representative situation when genomic position transformation needs to be applied. 
For example, there are regions which are quite densely located on the chromosome. 
If heatmap or text for those dense regions are to be plotted. They would be overlapped and 
hard to identify, also ugly to visualize. Thus, a way to transform original positions to 
new positions would help for the visualization.

Low-level genomic functions such as {\tt circos.genomicPoints} all accept an argument {\tt posTransform}
to apply user-defined position transformation. Value for {\tt posTransform} is a self-defined function which
only accepts at least one argument: a data frame with two columns (start position and end position). 
Because {\tt posTransform} is bound to low-level graphic functions, it is not necessary to add
chromosome information in the input data. There is only one requirement for position 
transformation: Number of rows of regions should be the same before and after the transformation. 

\subsubsection{The default position transformation function}

In \textbf{circlize}, there already provides a position transformation function {\tt posTransform.default} 
which distributes positions uniformly in the current chromosome.

Following code does the transformation. The points are plotted with the new transformed regions.

<<eval=FALSE>>=
circos.genomicTrackPlotRegion(data, panel.fun = function(region, value, ...) {
    circos.genomicPoints(region, value, posTransform = posTransform.default, ...)
})
@

Of course we need identification lines to connect the untransformed regions to the transformed
regions. There is a function called {\tt circos.genomicPosTransformLines} which does the job.
Same value for {\tt posTransform} which was used before should be passed to {\tt circos.genomicPosTransformLines}.
Note {\tt circos.genomicPosTransformLines} will create a new track to put such identification lines.
In the function, {\tt direction} controls whether the position transformed track is inside or outside
the identification line track, and {\tt horizontalLine} controls whether add lines to identify the regions.


<<eval=FALSE>>=
circos.genomicPosTransformLines(data, posTransform = posTransform.default)
circos.genomicPosTransformLines(data, posTransform = posTransform.default,
    horizontalLine = "top")
circos.genomicPosTransformLines(data, posTransform = posTransform.default,
    direction = "outside")
@

In following example, we make heatmap for selected regions in the genome (figure \ref{fig:genomic_postransform} A).

<<genomic_postransform_1, eval = FALSE>>=
circos.par(cell.padding = c(0, 0, 0, 0))
circos.initializeWithIdeogram()
bed = generateRandomBed(nr = 100, nc = 4)

# note how 'horizontalLine' works
circos.genomicPosTransformLines(bed, posTransform = posTransform.default, 
    horizontalLine = "top", track.height = 0.1)

f = colorRamp2(breaks = c(-1, 0, 1), colors = c("green", "black", "red"))
circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        circos.genomicRect(region, value, col = f(value[[1]]), 
            border = f(value[[1]]), posTransform = posTransform.default, ...)
}, bg.border = NA)

circos.clear()
@

For the second example, the heatmap is plotted outside the identification lines, so here
{\tt direction} is set to {\tt outside} (figure \ref{fig:genomic_postransform} B). 
Also note how we add the ideogram inside the circle.

<<genomic_postransform_2, eval = FALSE>>=
circos.par(cell.padding = c(0, 0, 0, 0))
circos.initializeWithIdeogram(plotType = NULL)

circos.genomicTrackPlotRegion(bed, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        circos.genomicRect(region, value, col = f(value[[1]]), 
            border = f(value[[1]]), posTransform = posTransform.default, ...)
}, bg.border = NA)

circos.genomicPosTransformLines(bed, posTransform = posTransform.default, 
    direction = "outside", horizontalLine = "bottom", track.height = 0.1)

cytoband = read.cytoband()$df
circos.genomicTrackPlotRegion(cytoband, stack = TRUE, 
    panel.fun = function(region, value, ...) {
        circos.genomicRect(region, value, col = cytoband.col(value[[2]]), border = NA)
        xlim = get.cell.meta.data("xlim")
        ylim = get.cell.meta.data("ylim")
        circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], border = "black")
}, track.height = 0.05, bg.border = NA)

circos.clear()
@

<<genomic_postransform, echo = FALSE, out.width = "0.6\\textwidth", out.height = "1.2\\textwidth", fig.width = 6, fig.height = 12, fig.cap = "Position transformation with {\\tt posTransform.default}. A) transformation is inside; B) transformation is outside.">>=
par(mfrow = c(2, 1), mar = c(1, 1, 1, 1))
<<genomic_postransform_1>>
text(-0.9, 0.9, "A", cex = 1.5)
<<genomic_postransform_2>>
text(-0.9, 0.9, "B", cex = 1.5)
par(mfrow = c(1, 1))
@

\subsubsection{Position transformation for text}

There is another position transformation function {\tt posTransform.text} provided in \textbf{circlize} that can smartly position
text on the circle. Normally, we don't want the text too away from the original position
and also we want to get avoid of text overlapping. {\tt posTransform.text} calculates the height of 
text and transform positions properly. Since such text position transformation relies on font size of text
and which track the text is in, the usage of {\tt posTransform.text} is a little bit complex. 
Currently, {\tt posTransform.text} only makes sense if it is called inside {\tt circos.genomicText} 
and only works when {\tt facing} is set to {\tt clockwise} or {\tt reverse.clockwise}.

In following example code, using {\tt posTransform.text} is quite similar as {\tt posTransform.default}
(but note this function is quit experimental):

<<eval=FALSE>>=
bed = generateRandomBed(nr = 400, fun = function(k) rep("text", k))
circos.genomicTrackPlotRegion(bed, ylim = c(0, 1), 
    panel.fun = function(region, value, ...) {
        circos.genomicText(region, value, y = 0, labels.column = 1, 
            facing = "clockwise", adj = c(0, 0.5), 
            posTransform = posTransform.text, cex = 0.8)
}, track.height = 0.1, bg.border = NA)
@

For the next track where position transformation lines are plotted. Code will be more complex.
Since the calculation of the position of the line ends which corresponds to the transformed track
relies on text settings (e.g. font size, font family) and track for the text (i.e.
the track will affect the position of text), we need to go back to the track where text position transformation happened
and use the same settings for the text. Such information should be collected when plotting transformation lines.
The solution by \textbf{circlize} is to wrap {\tt posTransform.text} with such information,
then text information will be recovered and the transformation will be calculated in the correct track.

As we mentioned before, {\tt posTransform} expect at least one argument, so the argument {\tt value}
is completely fine here.

<<eval=FALSE>>=
i_track = get.cell.meta.data("track.index")  # the nearest track
# we put `y`, `labels`, ... into a self-defined function
# because these parameters will affect the text position
circos.genomicPosTransformLines(bed, direction = "outside",
    posTransform = function(region, value) 
        posTransform.text(region, y = 0, labels = value[[1]], 
            cex = 0.8, track.index = i_track)
)
@

If the transformation line track is plotted before the track where text position is transformed, 
things will be more complicated. Since {\tt circos.genomicPosTransformLines} 
needs information of the text, but at that moment, track which transforms text positions 
has not be created. The solution is first creating an empty track for position transformation lines, 
then adding the position transformation track. Finally go back to the 
transformation line track to add transformation lines.

<<eval=FALSE>>=
circos.genomicTrackPlotRegion(bed, ylim = c(0, 1), track.height = 0.1, bg.border = NA)
i_track = get.cell.meta.data("track.index")  # remember this empty track, we'll come back

circos.genomicTrackPlotRegion(bed, ylim = c(0, 1),
    panel.fun = function(region, value, ...) {
        circos.genomicText(region, value, y = 1, labels.column = 1, 
            facing = "clockwise", adj = c(1, 0.5),
            posTransform = posTransform.text, cex = 0.8)
}, track.height = 0.1, bg.border = NA)
tr_track = get.cell.meta.data("track.index") # position transformation track

# because `circos.genomicPosTransformLines` is implemented by 
# `circos.trackPlotRegion`, it accepts `track.index` argument.
circos.genomicPosTransformLines(bed, 
    posTransform = function(region, value) 
        posTransform.text(region, y = 1, labels = value[[1]], 
            cex = 0.8, track.index = tr_track),
    direction = "inside", track.index = i_track
)
@

Padding of text after transformation can be set through {\tt padding} argument to adjust the space
between two neighbouring text. Of course, when add transformation lines, {\tt padding} should
also be wrapped in. 

<<eval=FALSE>>=
circos.genomicTrackPlotRegion(bed, ylim = c(0, 1), 
    panel.fun = function(region, value, ...) {
        circos.genomicText(region, value, y = 0, labels.column = 1, 
            facing = "clockwise", adj = c(0, 0.5), posTransform = posTransform.text, 
            cex = 0.8, padding = 0.2)
}, track.height = 0.1, bg.border = NA)

i_track = get.cell.meta.data("track.index")  # previous track
circos.genomicPosTransformLines(bed, 
    posTransform = function(region, value) posTransform.text(region, y = 0, 
        labels = value[[1]], cex = 0.8, padding = 0.2, track.index = i_track),
    direction = "outside"
)
@

For examples and comparisons between {\tt posTransform.default} and {\tt posTransform.text} when
visualizing text, please refer to figure \ref{fig:genomic_text_pos_transformation}. Source code
is available in the help page of {\tt posTransform.text}.

<<genomic_text_pos_transformation, echo = FALSE, out.width = "\\textwidth", fig.cap = "Transformation of text positions.">>=
source("src/genomic-07-posTransformLinesText.R")
@

\subsubsection{How about if I have a lot of labels?}

Position transformation is applied inside each chromosome, which means, the transformed new positions
are still located in the original chromosome. This would cause a problem that if you have 
a lot of labels to put, they will overlap with each other (figure \ref{fig:genome_more_labels} B). Unfortunately there is no simple solution
to extend the positions outside of the chromosome.

Anyway, we provide a 'not-too-perfect' solution but the code is a little bit lengthy (figure \ref{fig:genome_more_labels} A). The idea
is to put labels and transformation lines in one same track. Here we use {\tt posTransform.text}
directly to calculate the transformed positions.

To make a clear demonstration, we only add graphics in the first quarter of the circle, only 
on one chromosome.

<<genome_more_labels_1, eval = FALSE>>=
set.seed(999)
bed = generateRandomBed(nr = 800, fun = function(k) rep("text", k))

par(mar = c(1, 1, 1, 1))
circos.par(start.degree = 75, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), 
    gap.degree = 300, cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0))
circos.initializeWithIdeogram(plotType = NULL, chromosome.index = "chr1")
@

The steps inside {\tt panel.fun} are:

\begin{enumerate}
    \item Original positions are plotted as dots.
    \item In order to get rid of text overlapping, we separate the text into two groups.
    One group of text are plotted lower than the other group. In following code, the x-axis 
    is splitted into 6 intervals and {\tt region} and {\tt value} are separated into groups
    by looking at whether the middle points of corresponding regions are in the odd intervals (i.e., the first interval, the third interval, ...)
    or even intervals. Of course, in this step, users should determine their own rule to separate the groups.
    \item Text in different groups are assigned with different heights ({\tt y}).
    \item Do the position transformation on text and add labels.
    \item Add the position transformation lines manually. Note the line for lower text and higher text
    are different. We do something more to make sure lines which points to higher text do not overlap
    with lower text too much.
\end{enumerate}

<<genome_more_labels_2, eval = FALSE>>=
circos.genomicTrackPlotRegion(bed, ylim = c(0, 1), 
    panel.fun = function(region, value, ...) {
    
    # original positions
    circos.genomicPoints(region, data.frame(rep(0, nrow(region))), pch = 16)
        
    xlim = get.cell.meta.data("xlim")
    breaks = seq(xlim[1], xlim[2], length.out = 7)
    midpoints = (region[[1]] + region[[2]])/2
    for(i in seq_along(breaks)[-1]) {
        # index for current interval
        l = midpoints >= breaks[i - 1] & midpoints < breaks[i]
        # if there is no data in this interval
        if(sum(l) == 0) next
        
        # sub-regions in this interval
        sub_region = region[l, , drop = FALSE]
        sub_value = value[l, , drop = FALSE]
        
        # note here i == 2, 4, 6, ... corresponds to odd intervals
        # text in odd intervals are in lower position
        if(i %% 2 == 0) {
            y = 0.2
        } else {
            y = 0.8
        }
        
        # get the transformed position and add text with new positions
        tr_region = posTransform.text(sub_region, y = y, labels = sub_value[[1]], 
            cex = 0.8, adj = c(0, 0.5))
        circos.genomicText(tr_region, sub_value, labels.column = 1, y = y, 
            adj = c(0, 0.5), facing = "clockwise", niceFacing = TRUE, cex = 0.8)
        
        # add position transformation lines for odd intervals
        if(i %% 2 == 0) {    
            for(i in seq_len(nrow(sub_region))) {
                x = c( (sub_region[i, 1] + sub_region[i, 2])/2,
                       (sub_region[i, 1] + sub_region[i, 2])/2,
                       (tr_region[i, 1] + tr_region[i, 2])/2,
                       (tr_region[i, 1] + tr_region[i, 2])/2)
                y = c(0, 0.2/3, 0.2/3*2, 0.2)
                circos.lines(x, y)
            }
        } else { # add position transformation lines for even intervals
            median_sub_region_midpoint = median(midpoints[l])
            sub_region_width = max(midpoints[l]) - min(midpoints[l])
            for(i in seq_len(nrow(sub_region))) {
                x = c( (sub_region[i, 1] + sub_region[i, 2])/2,
                       (sub_region[i, 1] + sub_region[i, 2])/2,
                       median_sub_region_midpoint + 
                           sub_region_width*(i - nrow(sub_region))/nrow(sub_region) * 0.2,
                       median_sub_region_midpoint + 
                           sub_region_width*(i - nrow(sub_region))/nrow(sub_region) * 0.2,
                       (tr_region[i, 1] + tr_region[i, 2])/2,
                       (tr_region[i, 1] + tr_region[i, 2])/2)
                y = c(0, 0.1, 0.2, 0.6, 0.7, 0.8)
                circos.lines(x, y)
            }
        }
    }
    
}, track.height = 0.2, bg.border = NA)

circos.clear()
@

You can self-define positions of the `necks' of the long transformation lines so that
they will not overlap with the lower text.

<<genome_more_labels, echo = FALSE, out.width = "\\textwidth", out.height = "0.5\\textwidth", fig.width = 14, fig.height = 7, fig.cap = "Position transformation for a lot of text. A) put text on two layers; B) put text on one layer.">>=
par(mfrow = c(1, 2), mar = c(1, 1, 1, 1))
<<genome_more_labels_1>>
text(0.1, 0.1, "A", cex = 1.5)

<<genome_more_labels_2>>
par(mar = c(1, 1, 1, 1))
circos.par(start.degree = 75, canvas.xlim = c(0, 1), canvas.ylim = c(0, 1), gap.degree = 300, cell.padding = c(0, 0, 0, 0), track.margin = c(0, 0))
circos.initializeWithIdeogram(plotType = NULL, chromosome.index = "chr1")
circos.genomicTrackPlotRegion(bed, ylim = c(0, 1), panel.fun = function(region, value, ...) {
    circos.genomicText(region, value, y = 0, labels.column = 1, facing = "clockwise", adj = c(0, 0.5),
        posTransform = posTransform.text, cex = 0.8, niceFacing = F)
}, track.height = 0.1, bg.border = NA)
i_track = get.cell.meta.data("track.index")

circos.genomicPosTransformLines(bed, 
    posTransform = function(region, value) posTransform.text(region, y = 0, labels = value[[1]], cex = 0.8, track.index = i_track),
    direction = "outside"
)

circos.genomicTrackPlotRegion(bed, ylim = c(0, 1), panel.fun = function(region, value, ...) {
    circos.points( (region[[1]] + region[[2]])/2, rep(0.5, nrow(region)), pch = 16)
}, track.height = 0.02, bg.border = NA)

circos.clear()

text(0.1, 0.1, "B", cex = 1.5)
@

